{"version":3,"names":["_helperEnvironmentVisitor","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_core","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","t","ns","exports","environmentVisitor","default","skipAllButComputedKey","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","delete","template","expression","ast","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nconst {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} = t;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  const ns = require(\"@babel/helper-environment-visitor\");\n  // eslint-disable-next-line no-restricted-globals\n  exports.environmentVisitor = ns.default;\n  // eslint-disable-next-line no-restricted-globals\n  exports.skipAllButComputedKey = ns.skipAllButComputedKey;\n}\n\ntype ThisRef =\n  | {\n      memo: t.AssignmentExpression;\n      this: t.Identifier;\n    }\n  | { this: t.ThisExpression };\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  t.MemberExpression & {\n    object: t.Super;\n    property: Exclude<t.MemberE